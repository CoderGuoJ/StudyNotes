
# 第5章:深入了解kafka

1. 集群成员关系
   1. 集群通过zookeeper维护成员关系，每个broker都有一个唯一id，通过在zookeeper上注册临时节点实现服务发现
   2. 关闭broker时，他注册的节点也会消失，但是唯一id会保存起来，如果启动另一个相同id的broker，数据也会保留下来
2. 控制器
   1. 第一个启动的broker会在zookeeper中注册一个/controller临时节点，并负责分区leader的选举
   2. 其它的broker也会在zookeeper中注册控制节点，但是会收到节点存在异常后退出
   3. 当控制器断开时其它broker会监听到zookeeper事件并尝试注册控制节点，注册成功的broker会生成一个新的值更大的epoch消息，以使其它broker忽略之前epoch的控制器消息
   4. 失去leader的分区会重新分配leader，一般为分区列表中的下一个副本
   5. 控制器通过epoch避免脑裂
3. 复制
   1. 首领副本
      1. 为保证一致性，所有生产者消费者的请求都会通过首领副本
   2. 跟随者副本
      1. 跟随者副本不会处理客户端请求，只会从首领副本处复制消息
      2. 如果首领副本崩溃，将会从跟随者副本选举新的首领副本
   3. 跟随者同步数据是顺序的，没有完全同步数据的跟随者副本无法成为新的首领
   4. 首选首领
      1. 每个topic会有一个首选首领，首选首领是通过负载均衡后得到的，如果为同步状态会优先变成首领
4. 处理请求
   1. broker提供了二进制协议来指定请求消息的格式和如果响应消息
   2. 消息头
      1. request type(API key)
      2. request version(broker 可以处理不同版本的客户端请求)
      3. correcorrelation id (具有唯一性的数字,用于标示请求消息,同时也会出现在响应消息与错误日志中,方便定位问题)
      4. client id (用于标示发送请求的客户端)
   3. 处理请求的流程
      1. broker在每个监听的端口上运行一个acceptor线程,这个线程会创建链接,并把它交给processes线程(也叫网络线程)处理
      2. 网络线程会将请求放入请求队列,并从响应队列获取响应返回给客户端
      3. IO线程会处理请求队列中的请求
         1. 生产请求,生产者发送的消息,它包含客户端要写入broker的消息
         2. 获取请求,消费者和跟随者副本需要从broker中读取消息时发送的请求
