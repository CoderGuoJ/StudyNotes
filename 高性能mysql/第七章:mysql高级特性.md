
# 第七章:mysql高级特性

1. 分区表
   1. 分区表是一个独立的逻辑表，底层由多个物理子表组成，和普通表一样，具有完全相同的索引
   2. 分区表是由对底层表的封装实现的，mysql中没有全局索引，每个分区表的索引是独立的
   3. 分区的主要目的是将数据以较粗的粒度区分
   4. 分区表的使用场景
      1. 表非常大无法放到内存中或最后部分有热点数据
      2. 分区后数据更容易维护
      3. 分区表数据可以分布在不同的物理设备上，充分利用硬件资源
   5. 分区表的限制
      1. 一个表最多1024个分区
      2. 分区表达式必须是整数，或者返回整数的表达式，某些场景可以直接使用列来分区
      3. 如果分区字段中有主键和唯一索引列，所有主键和唯一索引列都需要包含进来
      4. 分区表中不能使用外键
   6. 分区表的操作逻辑
      1. select
         1. 分区层打开并锁定所有底层表，优化器判断是否可以过滤掉某些分区，然后调用存储引擎访问各个分区的数据
      2. insert
         1. 分区层打开并锁定所有底层表，确定哪个分区接收这条记录，然后在对应的分区中写入
      3. delete
         1. 分区层打开并锁定所有底层表，确定数据对应的分区，然后对底层表数据进行删除
      4. update
         1. 分区层打开并锁定所有底层表，取出对应分区的数据，再将新数据插入到其对应的分区中，最后删除之前的数据
      5. 虽然每个操作都会锁定所有底层表，但是在有行级锁的存储引擎上会释放表锁，添加行级锁
   7. 分区表的类型
      1. 按键值分区，减少innodb互斥量竞争
      2. 使用数学模函数分区
      3. 根据数据范围分区
   8. 分区表的使用
      1. 全量数据，不需要任何索引
      2. 索引数据，并分离热点数据
   9. 分区表可能存在的问题
      1. null值会使分区过滤无效
      2. 分区列和索引列不同时会导致查询无法做分区过滤
      3. 选择分区的成本可能很高（只针对范围分区表）
      4. 打开并锁住所有底层表的成本可能很高
      5. 维护分区的成本可能很高，alter table会复制移动大量的数据
      6. 所有分区的存储引擎必须相同
      7. 分区函数中可使用的表达式有限制
      8. 某些存储引擎不支持分区
   10. 查询优化
       1. 在查询中的where语句中存在分区列可以进行分区过滤，关于分区列的表达式无法过滤
       2. 即使创建分区表时使用了表达式，也只能通过列来过滤
2. 视图
   1. 视图是一张虚拟表，不存放任何数据，返回对应mysql表的数据
   2. 将视图定义的sql直接包含进查询的sql中可以提高视图查询的性能
   3. 视图有两种实现方式
      1. 合并算法
      2. 临时表算法
   4. 可更新视图
      1. 可以通过更新视图来更新视图相关的表数据
      2. 视图定义中存在复杂函数、聚合时无法更新
      3. 临时表视图无法更新
   5. 视图对性能的影响
      1. 视图并发简单的表查询，其实现逻辑可能会很复杂
      2. 视图无法使用索引
   6. 视图的限制
      1. mysql无法为视图创建索引
      2. 视图创建sql难以获取
3. 外键约束
   1. 修改数据时每次都会在另一个表中多做一次查询操作
   2. 需要额外的锁
   3. 有时用触发器代替外键性能可能会更好
   4. 尽量少的使用，对性能有较大的影响
4. 在mysql内部存储代码
   1. 触发器、存储过程、函数、定时任务(事件)
   2. 存储过程和存储函数可以接收参数然后返回值，触发器和事件不行
   3. 优点
      1. 在服务器内部执行，离数据更近，节省带宽
      2. 代码重用，方便的统一业务规则，安全性高
      3. 简化代码维护和版本更新
      4. 可以做权限控制
      5. 存储过程执行计划会在服务端缓存，提高性能
      6. 分离数据库开发人员与应用开发人员
   4. 缺点
      1. mysql没有提供开发和调试工具
      2. 存储过程代码执行效率更低
      3. 存储代码会给项目部署带来额外的复杂性
      4. 给服务器造成额外的压力
   5. 存储过程和函数
      1. 限制
         1. 优化器无法使用关键字deterministic来优化单次查询多次调用存储函数的情况
         2. 优化器无法估算执行成本
         3. 每个连接的存储过程是独立保存的，无法复用
      2. 多个小程序的情况使用存储过程可以提升性能，减少网络开销
   6. 触发器
      1. 触发器可以读取和修改insert、delete、update涉及的数据
      2. 注意
         1. 每个表的每一个事件的触发器只能定义一次
         2. mysql只支持基于行的触发器
         3. 触发器可以掩盖服务器内部的操作
         4. 相关的问题很难排查
         5. 触发器失败会导致sql执行失败，触发器可能会导致死锁和锁等待
   7. 事件
      1. 类似于linux的定时任务
5. 游标
   1. 只读、单向
   2. 基于临时表实现，总是访问所有数据
   3. 如果关闭游标的时候只扫描了大结果集的一部分结果就会带来额外开销
6. 绑定变量
   1. 类似于一个sql模版，在使用的时候将问号位置的内容传入即可
   2. 优点
      1. 在服务端只需要解析一次sql语句即可
      2. 优化器只需要执行一次
      3. 网络开销更小，只需要发送参数和句柄
      4. 更安全，避免sql注入
   3. 绑定变量的优化
      1. 解析sql时，移除不可能条件，重写子查询
      2. 简化嵌套循环的关联，将外关联转换为内关联
      3. 过滤分区
      4. 尽量移除count、min、max
      5. 移除常数表达式
      6. 检测常量表
      7. 做必要的等值传播
      8. 优化关联顺序
   4. 限制
      1. 会话级别，多个连接之间不能共享绑定变量
      2. mysql5.1之前，绑定变量的sql不能使用查询缓存
      3. 如果只执行一次sql的话，绑定变量会产生更多的性能开销
      4. 存储函数中无法使用(存储过程中可以)
      5. 如果忘记释放绑定变量资源会产生资源泄漏，对其它线程产生影响
7. 用户自定义函数
   1. 存储过程只能使用sql，udf没有这个限制
   2. udf可能会使服务器崩溃，扰乱服务器的内存和数据
   3. 升级mysql需要重写编译udf
   4. 要确保udf是线程安全的
8. 字符集和校对
    1. 创建数据库的字符集
    2. 创建表的字符集
    3. 创建列的字符集
    4. 越小范围的字符串越优先
9. 查询缓存
   1. 查询缓存保存了查询的完整结果，当查询命中该缓存时mysql会立即返回结果
   2. 如果涉及缓存的表发生变化，缓存将会删除
   3. 如何判断命中缓存
      1. 如果查询中包含不确定的值或函数时，结果不会被缓存
   4. 查询缓存会带来额外的服务器开销
      1. 读操作会检测是否命中缓存
      2. 如果这个查询可以被缓存，就将结果数据保存到缓存中
      3. 写操作会将涉及到的所有缓存失效(失效操作有全局锁)，如果缓存很大会严重影响到性能
   5. 查询缓存如何使用内存
      1. 完整数据由40k结构数据和若干数据块构成
      2. 先锁住空间块，然后选择尽量小的内存块存入，如果没有则创建新的内存块存入，查询完成后如果内存空间有剩余就释放新内存，存入释放出的内存块
   6. 什么情况查询缓存会产生作用
      1. 缓存为命中可能的原因
         1. 查询语句无法被缓存
         2. mysql从未处理过这个查询
         3. 查询缓存过期或被移除了
