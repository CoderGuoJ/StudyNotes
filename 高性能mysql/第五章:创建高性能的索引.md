
# 第五章:创建高性能的索引

- 索引顺序十分重要,mysql只能匹配最左前缀列
- 索引的类型
  - B-Tree索引
    - 适用于全键值、键值范围、键前缀查询
    - 全值匹配
      - 和索引中的所有列匹配
    - 匹配最左前缀
    - 匹配列前缀
    - 匹配范围值
    - 精确匹配某一列并范围匹配另一列
    - 只访问索引的查询
    - 索引限制
      - 如果不是按照索引的最左列查询,则无法访问索引
      - 不能跳过索引中的列
      - 某个列的范围查询时,其右侧索引都将失效
  - 哈希索引
    - 基于哈希表创建索引,只有精确匹配才有效
    - 只有Memory显示支持哈希索引
    - 如果多个列的哈希值相同会以列表方式保存
    - 索引内容只包含哈希值和行指针,需要额外读取行数据,内存很快,影响不大
    - 不是按照顺序存储,无法应用与排序
    - 哈希会包括所有列,不能在部分列上使用索引
    - 只支持等值查询,不支持范围查询
    - 如果哈希冲突将遍历链表
    - 冲突越多,查询代价越大
    - innodb引擎有"自适应哈希索引",结合B-Tree与哈希的优势
    - 可以手动维护一列哈希列,尽量不采用sha1或者md5,他们生成的哈希值比较长,通常没有必要,尽量采用数字类型
  - 空间数据索引
    - mysql支持不是很好,很少用,只支持gis相关函数的操作
  - 全文索引
    - 查询文本中的关键字
- 索引的优点
  - 大大减少服务器需要扫描的数据量
  - 索引可以帮助服务器避免排序和临时表
  - 索引可以使随机I/O变为顺序I/O
- 高性能的索引策略
  - 独立的列,不应该存在于表达式中
- 前缀索引和索引选择性
  - 对于很长的字符串
    - 索引开始的部分字符
    - 前缀索引无法使用排序和分组
    - 如果想使用后缀索引可以反转字符串存储,再建立索引
- 多列索引
  - mysql5.0可以将多个独立的索引联合起来
  - and 条件通常需要一个包含所有列的复合索引
  - or 条件通常需要消耗大量的cpu与内存资源在缓存、排序和合并上
  - 优化器不会把索引组合操作计算到查询成本中,有时还不如全表扫描的性能
  - 出现索引合并(index merge)时要谨慎对待,查看查询和表结构是否最优
- 选择合适的索引顺序
  - 排序按照最左列排序,其次是第二列
  - 将选择性最高的列放在前面
- 聚簇索引
- 覆盖索引
  - 索引的叶子节点中包含需要的数据,无需回表查询
  - 优点
    - 索引条目通常远小于数据大小
    - 索引顺序存储,顺序I/O性能更好
    - 二级索引覆盖查询可以避免再次访问一级索引
- 使用索引扫描排序
  - 使用条件
    - 当索引列与order by子句顺序一致且所有列的排序方向一致时
    - 当多表关联时,所有order by子句引用的字段均为第一张表时
    - 前导列为常量时order by可以不满足最左前缀要求
