
# 第六章:查询性能优化

- 慢查询基础:优化数据访问
  - 确认查询是否有太多超过需要的行(列)
  - 确认mysql服务器层是否在分析大量超过需要的数据行
  - 是否向数据库请求了不需要的数据
    - 不需要的记录用limit
    - 多表关联不要select *
    - 尽量避免select * 这种写法
- 查询响应指标
  - 响应时间
    - 服务时间(处理查询时间)+排队时间(等待资源时间)
  - 扫描行数
    - 能说明该查询的效率
    - 扫描的行尽量与返回的行数相同
  - 返回行数
    - 以下三种情况,由好到坏
      - 在索引中使用where过滤不匹配的行,存储引擎层
      - 使用索引覆盖扫描,在索引中过滤不需要的数据并返回结果,mysql服务器层(Useing index)
      - 从数据表中返回数据然后过滤不需要的行,mysql服务器层(Useing where)
  - 重构查询的方式
    - 一个复杂查询还是多个简单查询
      - 尽量使用少的查询，mysql返回数据开销较大
      - 有时使用多个简单查询会极大减少工作量
    - 切分查询，将一个大的查询切分为若干个小的查询
      - 大的查询会产生大范围的锁,小的查询可以减少mysql同步延迟
    - 分解关联查询(先查询多个表，然后在程序中聚合)
      - 缓存的效率更高
      - 减少锁竞争
      - 在应用层关联可以更容易拆分、扩展
      - 查询效率更高
      - 减少冗余记录的查询
      - 相当于在应用层做了哈希关联,比mysql的循环嵌套关联更高效
  - 查询执行的基础
    - 执行流程
      - 客户端向服务器发送一条查询
      - 服务器检查缓存，如果有立即返回，如果没有进入下一阶段
      - 服务器执行sql解析、预处理，再由优化器生成对应的执行计划
      - mysql根据执行计划调用存储引擎api进行查询
      - 返回结果给客户端
    - mysql通信协议
      - 半双工，无需切分消息
      - 没有办法做流量控制
      - 客户端获取全部收据后保存到内存里
      - 查询状态
        - sleep 等待客户端发送请求
        - query 正在查询或正在将结果发送给客户端
        - locked 等待锁(行锁、表锁)
        - analyzing and statistics 收集存储引擎的统计信息，生成查询的执行计划
        - copying to tmp table [on disk] 将结果集存放在临时表中，如group by union等，on disk表示正在保存到磁盘
        - sorting result 对结果集排序
        - sending data 在多个状态间发送数据、或者在生成结果集、获取在向客户端发送数据
    - 查询缓存
      - 在解析一个查询语句之前，如果查询缓存打开，mysql会优先检查是否命中缓存
      - 通过一个对大小写敏感的哈希查找实现的(完全匹配)
      - 如果缓存命中，mysql会检查用户权限，然后直接返回给客户端数据
    - 查询优化处理
      - 语法解析器和预处理
        - mysql对sql进行解析，生成"查询树"并校验关键字语法
        - 语法正确后交由查询优化器处理，基于查询成本优化
        - 导致优化器错误选择的情况
          - 存储引擎统计的数据不准确
          - 成本估算不等同于实际执行成本
          - 不考虑其它并发查询
          - 不考虑不受mysql控制的操作成本，例如用户自定义函数
        - mysql的优化类型
          - 重新定义管理表的顺序
          - 将外连接转化成内链接
          - 使用等价变换规则
          - 优化count、min、max
          - 预估并转换为常数表达式
          - 覆盖索引扫描
          - 子查询优化
          - 提前终止查询
          - 等值传播
          - 列表in的比较转换为多个or
        - mysql的关联查询
          - 嵌套循环关联，用第一个表循环查询第二个表的数据（小表在前可以减少循环次数）
