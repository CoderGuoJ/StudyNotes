
# 第六章:查询性能优化

- 慢查询基础:优化数据访问
  - 确认查询是否有太多超过需要的行(列)
  - 确认mysql服务器层是否在分析大量超过需要的数据行
  - 是否向数据库请求了不需要的数据
    - 不需要的记录用limit
    - 多表关联不要select *
    - 尽量避免select * 这种写法
- 查询响应指标
  - 响应时间
    - 服务时间(处理查询时间)+排队时间(等待资源时间)
  - 扫描行数
    - 能说明该查询的效率
    - 扫描的行尽量与返回的行数相同
  - 返回行数
    - 以下三种情况,由好到坏
      - 在索引中使用where过滤不匹配的行,存储引擎层
      - 使用索引覆盖扫描,在索引中过滤不需要的数据并返回结果,mysql服务器层(Useing index)
      - 从数据表中返回数据然后过滤不需要的行,mysql服务器层(Useing where)
- 重构查询的方式
  - 一个复杂查询还是多个简单查询
    - 尽量使用少的查询，mysql返回数据开销较大
    - 有时使用多个简单查询会极大减少工作量
  - 切分查询，将一个大的查询切分为若干个小的查询
    - 大的查询会产生大范围的锁,小的查询可以减少mysql同步延迟
  - 分解关联查询(先查询多个表，然后在程序中聚合)
    - 缓存的效率更高
    - 减少锁竞争
    - 在应用层关联可以更容易拆分、扩展
    - 查询效率更高
    - 减少冗余记录的查询
    - 相当于在应用层做了哈希关联,比mysql的循环嵌套关联更高效
- 查询执行的基础
  - 执行流程
    - 客户端向服务器发送一条查询
    - 服务器检查缓存，如果有立即返回，如果没有进入下一阶段
    - 服务器执行sql解析、预处理，再由优化器生成对应的执行计划
    - mysql根据执行计划调用存储引擎api进行查询
    - 返回结果给客户端
  - mysql通信协议
    - 半双工，无需切分消息
    - 没有办法做流量控制
    - 客户端获取全部收据后保存到内存里
    - 查询状态
      - sleep 等待客户端发送请求
      - query 正在查询或正在将结果发送给客户端
      - locked 等待锁(行锁、表锁)
      - analyzing and statistics 收集存储引擎的统计信息，生成查询的执行计划
      - copying to tmp table [on disk] 将结果集存放在临时表中，如group by union等，on disk表示正在保存到磁盘
      - sorting result 对结果集排序
      - sending data 在多个状态间发送数据、或者在生成结果集、获取在向客户端发送数据
  - 查询缓存
    - 在解析一个查询语句之前，如果查询缓存打开，mysql会优先检查是否命中缓存
    - 通过一个对大小写敏感的哈希查找实现的(完全匹配)
    - 如果缓存命中，mysql会检查用户权限，然后直接返回给客户端数据
  - 查询优化处理
    - 语法解析器和预处理
      - mysql对sql进行解析，生成"查询树"并校验关键字语法
      - 语法正确后交由查询优化器处理，基于查询成本优化
      - 导致优化器错误选择的情况
        - 存储引擎统计的数据不准确
        - 成本估算不等同于实际执行成本
        - 不考虑其它并发查询
        - 不考虑不受mysql控制的操作成本，例如用户自定义函数
      - mysql的优化类型
        - 重新定义管理表的顺序
        - 将外连接转化成内链接
        - 使用等价变换规则
        - 优化count、min、max
        - 预估并转换为常数表达式
        - 覆盖索引扫描
        - 子查询优化
        - 提前终止查询
        - 等值传播
        - 列表in的比较转换为多个or
      - mysql的关联查询
        - 嵌套循环关联，用第一个表循环查询第二个表的数据（小表在前可以减少循环次数）
      - 执行计划
        - mysql生成指令树，存储引擎执行指令树并返回结果
        - 并非平衡树，而是最初深度优先树
      - 关联查询优化器
        - 遍历执行计划树的成本，选出最优的执行计划
        - n个表有n的阶乘种关联顺序，超过optimizer_search_depth的时候会采用贪婪搜索模式
      - 排序优化
        - 文件排序
          - 数据量小在内存中执行"快速排序"排序
          - 数据量大需要使用磁盘分割数据排序再归并的方式排序
        - 排序算法
          - 两次传输排序（旧版）
            - 读取指针和需要排序的字段，排序后读取所需的数据行
            - 产生大量的随机I/O，传输成本很高
          - 单次传输排序（新版）
            - 先读取查询需要的所有列，再根据给定列排序，最后返回排序结果
            - 不需要从数据表中读取两次数据，提高性能，但是会占用额外的空间
          - 排序产生的临时文件可能会比原数据大很多倍，因为每个字段空间都需要足够长
    - 查询执行引擎
      - mysql根据执行计划调用存储引擎的api接口
    - 返回结果给客户端
      - 即使不需要返回结果集给客户端，mysql仍然会返回一些基本信息，如查询影响的行数
      - mysql只要产生一条结果就会返回给客户端，是一个增量的，逐步返回的过程
      - 每一行都会以mysql通信协议封包，通过tcp协议传输，tcp会有缓存，批量传输
- mysql查询优化器的局限性
  - 关联子查询
    - mysql不会先执行子查询，而是会将外层表压进子查询中，根据外层数据不断执行子查询
    - 一般使用左外连接代替in
  - union的限制
    - 在最后加limit会导致子表数据全部查询后再limit，可以将每个子表都做limit，最后也做limit
  - 索引合并优化
    - 等值传递
      - 例如in中是一个很大的列表，做等值传递时会使优化和执行都非常慢
    - 并行并发
      - mysql无法利用多核优势来并行执行查询
    - 哈希关联
      - mysql不支持哈希关联，但是可以通过建立一个哈希索引来模拟实现
    - 松散索引扫描
      - mysql不支持松散索引扫描，只能按照顺序在一定范围内依次扫描
    - 最大值和最小值优化
      - 如果没有索引，min和max都会扫描全表
    - 在同一张表上查询和更新
      - mysql不允许对同一张表同时执行查询和修改
- 查询优化器提示（hint）
  - 如果对优化器选择的执行计划不满意可以通过hint来控制最终生成的执行计划
  - high_priority和low_priority
    - 当多个语句同时访问某一张表时，哪个语句的优先级更高(更低)
    - 切勿使用在拥有细粒度锁的存储引擎中使用，如innodb，会导致并发插入被禁用，严重降低性能
    - 这俩个提示并不会增加或减少查询资源，只是简单的影响语句的访问顺序
  - delayed
    - 对insert和replace有效
    - mysql会立即返回结果给客户端，将执行语句放在缓冲区后批量执行
    - 会导致last_insert_id()失效
  - straight_join
    - 放在select关键字之后或者任意俩个关联表之间
    - 让查询中所有表按照在语句中出现的顺序关联
    - 固定前后俩表顺序
    - 可以通过explain查询关联顺序然后使用改提示重写查询
  - sql_small_result和sql_gib_result
    - 只对select生效，指定优化器对于group by和distict语句如何使用临时表和排序
    - sql_small_result优先使用内存临时表，sql_gib_result优先使用磁盘临时表
  - sql_buffer_result
    - 将查询结果放入临时表，尽可能快的释放表锁
    - 服务端将需要更大的内存
  - sql_cache和sql_no_cache
    - 结果集是否应该缓存在查询缓存中
  - sql_calc_found_rows
    - mysql会返回除去limit语句后返回的记录数，通过fount_row()获取
  - for_update和lock in share mode
    - 只对实现了行级锁的存储引擎(innodb)生效,为符合查询条件的数据添加行锁
    - 会导致某些优化无法正常工作
  - use index、ignore index、force index
    - 告诉优化器使用或不使用哪些索引进行查询
- 优化特定类型的查询
  - 快速、精确、实现简单，永远只能满足其二，需要有所舍弃
  - 优化count查询
    - 统计列值时要求列值非空
    - 使用explain获取行数的近似值非常高效
    - count需要访问大量数据才可以获取精确结果，可以采用统计表事先统计达到效果
  - 优化关联查询
    - 确保on和using子句的列上有索引
    - 一般情况只需要在关联顺序第二的表上建立索引即可
    - 确保group by和order by只包含一个表中的字段才可以利用索引
  - 优化子查询
    - 尽可能的使用关联查询替代
  - 优化group by和distinct
    - 尽量利用索引
    - 尽量使用标示列分组，是有可以利用min和max代替分组
    - 如果没有指定order by，将会根据分组字段顺序进行排序，会影响性能，可以使用order by null取消默认排序
  - 优化limit分页
    - 可以采用添加一个关联查询，只返回一个id字段，用来定位记录，然后外层通过id查询行，这样可以有效的见效查询数据量
    - 记录上一次查询的记录号
  - 优化union查询
    - 如果不是必须要去重的话尽量使用union all，如果不加all的话mysql会自动添加distinct关键字，严重影响性能
  - 使用用户自定义变量
    - 使用自定义变量的查询无法使用查询缓存
    - 不能在标识符或者常量的地方使用
    - 持久化连接或者连接池可能会对多个查询产生关联影响
    - 5.0版本之前是大小写敏感的
    - 类型是动态的，无法指定，根据变量值确定
    - 优化器可能会优化用户变量导致查询执行异常
    - 使用未定义变量不会产生语法错误
